---
course_id: 6-852j-distributed-algorithms-fall-2009
layout: course_section
menu:
  leftnav:
    identifier: df97dc72d4cbf588e631716074525507
    name: Calendar
    weight: 20
title: Calendar
type: course
uid: df97dc72d4cbf588e631716074525507

---

| SES # | TOPICS | KEY DATES |
| --- | --- | --- |
| 1 | Course overview. Synchronous networks. Leader election in synchronous ring networks. | Homework 1a out |
| 2 | Leader election in rings. Basic computational tasks in general synchronous networks: leader election. Breadth-first search. Broadcast and convergecast. Shortest paths. | &nbsp; |
| 3 | Spanning trees. Minimum spanning trees. | Homework 1b out |
| 4 | Fault-tolerant consensus. Link failures: the two generals problem. Process failures (stopping, Byzantine). Algorithms for agreement with stopping and Byzantine failures. Exponential information gathering. | &nbsp; |
| 5 | Number-of-processor bounds for Byzantine agreement. Weak Byzantine agreement. Time bounds for consensus problems. |  {{< br >}}{{< br >}} Homework 1 due {{< br >}}{{< br >}} Homework 2a out {{< br >}}{{< br >}}  |
| 6 | _k_\-set-agreement. Approximate agreement. Distributed commit. | &nbsp; |
| 7 | Asynchronous distributed computing. Formal modeling of asynchronous systems using interacting state machines (I/O automata). Proving correctness of distributed algorithms. | Homework 2b out |
| 8 | Non-fault-tolerant algorithms for asynchronous networks. Leader election, breadth-first search, shortest paths, broadcast and convergecast. | &nbsp; |
| 9 | Spanning trees. Gallager _et al_. minimum spanning trees. |  {{< br >}}{{< br >}} Homework 2 due {{< br >}}{{< br >}} Homework 3a out {{< br >}}{{< br >}}  |
| 10 | Synchronizers. Synchronizer applications. Synchronous vs. asynchronous distributed systems. | Homework 3b out |
| 11 | Time, clocks, and the ordering of events. State-machine simulation. Vector timestamps. | &nbsp; |
| 12 | Stable property detection. Distributed termination. Global snapshots. Deadlock detection. |  {{< br >}}{{< br >}} Homework 3 due {{< br >}}{{< br >}} Homework 4a out {{< br >}}{{< br >}}  |
| 13 | Asynchronous shared-memory systems. The mutual exclusion problem. Mutual exclusion algorithms. | &nbsp; |
| 14 | More mutual exclusion algorithms. Bounds on shared memory for mutual exclusion. Resource allocation. The Dining Philosophers problem. | Homework 4b out |
| 15 | Shared-memory multiprocessors. Contention, caching, locality. Practical mutual exclusion algorithms. Reading/writing locks. | &nbsp; |
| 16 | Impossibility of consensus in asynchronous, fault-prone, shared-memory systems. |  {{< br >}}{{< br >}} Homework 4 due {{< br >}}{{< br >}} Homework 5a out {{< br >}}{{< br >}}  |
| 17 | Atomic objects | &nbsp; |
| 18 | Atomic snapshot algorithms. Atomic read/write register algorithms. | Homework 5b out |
| 19 | List algorithms: locking algorithms, optimistic algorithms, lock-free algorithms, lazy algorithms. | &nbsp; |
| 20 | Transactional memory: obstruction-free and lock-based implementations. |  {{< br >}}{{< br >}} Homework 5 due {{< br >}}{{< br >}} Homework 6a out {{< br >}}{{< br >}}  |
| 21 | Wait-free computability. The wait-free consensus hierarchy. | Homework 6b out |
| 22 | Wait-free vs. _f_\-fault-tolerant atomic objects. Boosting fault-tolerance. | &nbsp; |
| 23 | Asynchronous network model vs. asynchronous shared-memory model. Impossibility of consensus in asynchronous networks. Failure detectors and consensus. Paxos consensus algorithm. |  {{< br >}}{{< br >}} Homework 6 due {{< br >}}{{< br >}} Homework 7 out {{< br >}}{{< br >}}  |
| 24 | Self-stabilizing algorithms | &nbsp; |
| 25 | Timing-based systems. Modeling and verification. Timing-based algorithms for mutual exclusion and consensus. Clock synchronization. | Homework 7 due