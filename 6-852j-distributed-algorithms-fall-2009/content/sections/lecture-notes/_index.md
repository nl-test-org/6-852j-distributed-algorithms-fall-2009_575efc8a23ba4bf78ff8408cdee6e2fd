---
course_id: 6-852j-distributed-algorithms-fall-2009
layout: course_section
menu:
  leftnav:
    identifier: f492f5bb8d3cf42982c3260e683f5f34
    name: Lecture Notes
    weight: 40
title: Lecture Notes
type: course
uid: f492f5bb8d3cf42982c3260e683f5f34

---

Lectures 15, 21, and 22 were given by guest lecturer Dr. Victor Luchangco of Sun Microsystems, and are used with permission.

| SES # | TOPICS | LECTURE NOTES |
| --- | --- | --- |
| 1 | Course overview. Synchronous networks. Leader election in synchronous ring networks. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec01)) |
| 2 | Leader election in rings. Basic computational tasks in general synchronous networks: leader election. Breadth-first search. Broadcast and convergecast. Shortest paths. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec02)) |
| 3 | Spanning trees. Minimum spanning trees. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec03)) |
| 4 | Fault-tolerant consensus. Link failures: the two generals problem. Process failures (stopping, Byzantine). Algorithms for agreement with stopping and Byzantine failures. Exponential information gathering. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec04)) |
| 5 | Number-of-processor bounds for Byzantine agreement. Weak Byzantine agreement. Time bounds for consensus problems. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec05)) |
| 6 | _k_\-set-agreement. Approximate agreement. Distributed commit. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec06)) |
| 7 | Asynchronous distributed computing. Formal modeling of asynchronous systems using interacting state machines (I/O automata). Proving correctness of distributed algorithms. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec07)) |
| 8 | Non-fault-tolerant algorithms for asynchronous networks. Leader election, breadth-first search, shortest paths, broadcast and convergecast. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec08)) |
| 9 | Spanning trees. Gallager _et al_. minimum spanning trees. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec09)) |
| 10 | Synchronizers. Synchronizer applications. Synchronous vs. asynchronous distributed systems. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec10)) |
| 11 | Time, clocks, and the ordering of events. State-machine simulation. Vector timestamps. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec11)) |
| 12 | Stable property detection. Distributed termination. Global snapshots. Deadlock detection. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec12)) |
| 13 | Asynchronous shared-memory systems. The mutual exclusion problem. Mutual exclusion algorithms. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec13)) |
| 14 | More mutual exclusion algorithms. Bounds on shared memory for mutual exclusion. Resource allocation. The Dining Philosophers problem. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec14)) |
| 15 | Shared-memory multiprocessors. Contention, caching, locality. Practical mutual exclusion algorithms. Reading/writing locks. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec15)) |
| 16 | Impossibility of consensus in asynchronous, fault-prone, shared-memory systems. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec16)) |
| 17 | Atomic objects | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec17)) |
| 18 | Atomic snapshot algorithms. Atomic read/write register algorithms. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec18)) |
| 19 | List algorithms: locking algorithms, optimistic algorithms, lock-free algorithms, lazy algorithms. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec19)) |
| 20 | Transactional memory: obstruction-free and lock-based implementations. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec20)) |
| 21 | Wait-free computability. The wait-free consensus hierarchy. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec21)) |
| 22 | Wait-free vs. _f_\-fault-tolerant atomic objects. Boosting fault-tolerance. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec22)) |
| 23 | Asynchronous network model vs. asynchronous shared-memory model. Impossibility of consensus in asynchronous networks. Failure detectors and consensus. Paxos consensus algorithm. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec23)) |
| 24 | Self-stabilizing algorithms | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec24)) |
| 25 | Timing-based systems. Modeling and verification. Timing-based algorithms for mutual exclusion and consensus. Clock synchronization. | ([PDF]({{< baseurl >}}/sections/lecture-notes/mit6_852jf09_lec25))